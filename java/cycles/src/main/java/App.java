import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

    public static void main(String[] args) throws Exception {
        String fn = args.length > 0 ? args[0] : "./data/graph20.adj";
        App app = new App();
        Graph g = app.readGraph(fn);
        System.out.println(app.countCycles(g));
    }

    interface Graph {
        Stream<String> vertices();
        Stream<String> edges(String vertex);
    }

    Graph readGraph(String fn) throws Exception {
        Stream <String> lines = Files.lines(Paths.get(fn));
        final Map<String, List<String>> adj = lines
                .map( String::trim )
                .filter( s -> !s.isEmpty() && !s.startsWith("#"))
                .map(s -> s.split("\\s"))
                .collect(Collectors.toMap(
                        a -> a[0],
                        a -> Arrays.asList(a).subList(1, a.length)
                ));
        return new Graph() {
            @Override
            public Stream<String> vertices() {
                return adj.keySet().stream();
            }

            @Override
            public Stream<String> edges(String vertex) {
                List<String> targets = adj.get(vertex);
                if (targets == null) {
                    return Stream.empty();
                } else {
                    return targets.stream();
                }
            }
        };
    }

    Long countCycles(Graph g) throws Exception {
        Map<String, Long> cycles = new ConcurrentHashMap<>();
        List<Thread> threads = g.vertices().map( v -> {
                    Thread t = new Thread( () ->
                            countCyclesStartingAt(v, g, n -> cycles.put(v, n)));
                    t.start();
                    return t;
                }).collect(Collectors.toList());
        for (Thread t: threads) {
            t.join();
        }
        return cycles.values().stream().mapToLong( x -> x).sum();
    }

    void countCyclesStartingAt(String v, Graph g, Consumer<Long> report) {
        List<String> sp = Collections.singletonList(v);
        Long n = g.edges(v).mapToLong( t -> countCyclesAt(t, sp, g)).sum();
        report.accept(n);
    }

    long countCyclesAt(String v, List<String> path, Graph g) {
        if (v.equals(path.get(0))) {
            return 1L;
        } else if (v.compareTo(path.get(0)) > 0 && !path.contains(v)) {
            List<String> np = new ArrayList<>(path);
            np.add(v);
            return g.edges(v).mapToLong(t -> countCyclesAt(t, np, g)).sum();

        } else {
            return 0;
        }

    }
}
