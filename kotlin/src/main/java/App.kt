import kotlinx.coroutines.experimental.runBlocking
import java.io.File
import kotlin.coroutines.experimental.SequenceBuilder
import kotlin.coroutines.experimental.buildSequence

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
object App {
    @JvmStatic
    fun main(args: Array<String>) = runBlocking<Unit> {
        val n = if (args.isNotEmpty()) args[0] else "20"
        val graph = readGraph("../data/graph$n.adj")
        println(countCycles(graph))
    }

    suspend fun countCycles(graph: Graph): Int = findCycles(graph).count()
}

suspend fun findCycles(graph: Graph): Sequence<List<ID>> = buildSequence {
    for (vertex in graph.vertices()) {
        findCycles(listOf(vertex), graph)
    }
}

suspend fun SequenceBuilder<List<ID>>.findCycles(path: List<ID>, graph: Graph)  {
    if (path.isEmpty()) {
        return
    }
    for (tid in graph.edges(path.last())) {
        if (tid == path.first()) {
            yield(path)
        } else if (tid > path.first() && !path.contains(tid)) {
            findCycles(path + listOf(tid), graph)
        }
    }
}

fun readGraph(path: String): Graph =
        MapGraph(File(path).readLines(Charsets.UTF_8)
                .map { it.trim() }
                .filter { !it.startsWith("#") }
                .filter { !it.isEmpty() }
                .map { it.split(Regex("\\s"))}
                .map { it[0] to it.subList(1, it.size).asSequence()
                }.toMap())

typealias ID = String

interface Graph {
    fun vertices(): Sequence<ID>
    fun edges(vertex: ID): Sequence<ID>
}

class MapGraph(private val vs: Map<ID, Sequence<ID>>): Graph {
    override fun vertices(): Sequence<ID> = vs.keys.asSequence()

    override fun edges(vertex: ID): Sequence<ID> = vs[vertex] ?: sequenceOf()
}
