import kotlinx.coroutines.experimental.CommonPool
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.runBlocking
import java.io.File
import kotlin.coroutines.experimental.SequenceBuilder
import kotlin.coroutines.experimental.buildSequence



/*
 * This Java source file was generated by the Gradle 'init' task.
 */
object App {

    @JvmStatic
    fun main(args: Array<String>) {
        val n = if (args.isNotEmpty()) args[0] else "20"
        val graph = readGraph("../data/graph$n.adj")
        val mode = if (args.size > 1) args[1] else "cheesy"
        println(mode)
        val start = System.currentTimeMillis()
        val c = when (mode) {
            "sync" -> countCyclesSync(graph)
            "cheesy" -> countCyclesCheesy(castGraph(graph, { it.toInt() } ))
            else -> countCyclesAsync(graph)
        }
        val t = System.currentTimeMillis() - start
        println("found $c cycles in $t ms")
    }

    fun <T: Comparable<T>> countCyclesAsync(graph: Graph<T>): Long = runBlocking {
        val callables = graph.vertices().map { vid -> async(CommonPool) {
            buildSequence { findCycles(listOf(vid), graph)}.count().toLong()
        } }
        val ln: List<Long> = callables.map { it.await() }
        ln.sum()
    }

    fun <T: Comparable<T>> countCyclesSync(graph: Graph<T>): Long {
        val seq = buildSequence {
            for (v in graph.vertices()) {
                findCycles(listOf(v), graph)
            }
        }
        return seq.count().toLong()
    }

    fun countCyclesCheesy(graph: Graph<Int>): Long = runBlocking {
        val callables = graph.vertices().map { vid -> async(CommonPool) {
            countCStyle(vid, vid, 0L, graph)
        } }
        val ln: List<Long> = callables.map { it.await() }
        ln.sum()
    }
}


suspend fun <T: Comparable<T>> SequenceBuilder<List<T>>.findCycles(path: List<T>, graph: Graph<T>)  {
    if (path.isEmpty()) {
        return
    }
    for (tid in graph.edges(path.last())) {
        if (tid == path.first()) {
            yield(path)
        } else if (tid > path.first() && !path.contains(tid)) {
            findCycles(path + listOf(tid), graph)
        }
    }
}

fun readGraph(path: String): Graph<String> =
        MapGraph(File(path).readLines(Charsets.UTF_8)
                .map { it.trim() }
                .filter { !it.startsWith("#") }
                .filter { !it.isEmpty() }
                .map { it.split(Regex("\\s"))}
                .map { it[0] to it.subList(1, it.size)
                }.toMap())


interface Graph<T : Comparable<T>> {
    fun vertices(): List<T>
    fun edges(vertex: T): List<T>
}

class MapGraph<T: Comparable<T>>(private val vs: Map<T, List<T>>): Graph<T> {
    override fun vertices(): List<T> = vs.keys.toList()

    override fun edges(vertex: T): List<T> = vs[vertex] ?: listOf()
}

fun <T : Comparable<T>, S : Comparable<S>> castGraph(graph: Graph<T>, convert: (T) -> S): Graph<S> {
    val verts = graph.vertices().map { it to convert(it) }
    val m: Map<S, List<S>> = verts.map { it.second to graph.edges(it.first).map(convert) }.toMap()
    return MapGraph(m)
}

fun countCStyle(start: Int, end: Int, path_mask: Long, graph: Graph<Int>): Long {
    var count = 0L
    for (target in graph.edges(end)) {
        if (target == start) {
            count++
        } else if (target > start) {
            val target_mask = 1L.shl(target)
            val in_path = path_mask.and(target_mask)
            if (in_path == 0L) {
                count += countCStyle(start, target, path_mask.or(target_mask), graph);

            }
        }
    }
    return count;
}
