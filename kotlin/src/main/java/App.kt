import kotlinx.coroutines.experimental.Deferred
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.channels.Channel
import kotlinx.coroutines.experimental.channels.count
import kotlinx.coroutines.experimental.launch
import kotlinx.coroutines.experimental.runBlocking
import java.io.File
import kotlin.coroutines.experimental.SequenceBuilder
import kotlin.coroutines.experimental.buildSequence

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
object App {
    @JvmStatic
    fun main(args: Array<String>) = runBlocking<Unit> {
        val n = if (args.isNotEmpty()) args[0] else "20"
        val graph = readGraph("../data/graph$n.adj")
        println(countCyclesChannel(graph))
    }

    suspend fun countCyclesChannel(graph: Graph): Int {
        val channel = Channel<List<ID>>(50)
        findCyclesChannel(graph, channel)
        return channel.count()
    }

    suspend fun countCycles(graph: Graph): Int = findCycles(graph).count()
}


suspend fun findCyclesChannel(graph: Graph, channel: Channel<List<ID>>) {
    val jobs = graph.vertices().map { async { findCyclesChannel(listOf(it), graph, channel) } }
    launch {
        for (job in jobs) {
            job.join()
        }
        channel.close()
    }
}

suspend fun findCyclesChannel(path: List<ID>, graph: Graph, channel: Channel<List<ID>>) {
    if (path.isEmpty()) {
        return
    }
    val jobs = mutableListOf<Deferred<Unit>>()
    for (tid in graph.edges(path.last())) {
        if (tid == path.first()) {
            channel.send(path)
        } else if (tid > path.first() && !path.contains(tid)) {
            jobs.add( async { findCyclesChannel(path + listOf(tid), graph, channel) })
        }
    }
    for (job in jobs) {
        job.join()
    }
}

suspend fun findCycles(graph: Graph): Sequence<List<ID>> = buildSequence {
    for (vertex in graph.vertices()) {
        findCycles(listOf(vertex), graph)
    }
}

suspend fun SequenceBuilder<List<ID>>.findCycles(path: List<ID>, graph: Graph)  {
    if (path.isEmpty()) {
        return
    }
    for (tid in graph.edges(path.last())) {
        if (tid == path.first()) {
            yield(path)
        } else if (tid > path.first() && !path.contains(tid)) {
            findCycles(path + listOf(tid), graph)
        }
    }
}

fun readGraph(path: String): Graph =
        MapGraph(File(path).readLines(Charsets.UTF_8)
                .map { it.trim() }
                .filter { !it.startsWith("#") }
                .filter { !it.isEmpty() }
                .map { it.split(Regex("\\s"))}
                .map { it[0] to it.subList(1, it.size).asSequence()
                }.toMap())

typealias ID = String

interface Graph {
    fun vertices(): Sequence<ID>
    fun edges(vertex: ID): Sequence<ID>
}

class MapGraph(private val vs: Map<ID, Sequence<ID>>): Graph {
    override fun vertices(): Sequence<ID> = vs.keys.asSequence()

    override fun edges(vertex: ID): Sequence<ID> = vs[vertex] ?: sequenceOf()
}
