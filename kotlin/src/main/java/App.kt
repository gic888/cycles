import kotlinx.coroutines.experimental.Deferred
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.channels.Channel
import kotlinx.coroutines.experimental.channels.count
import kotlinx.coroutines.experimental.launch
import kotlinx.coroutines.experimental.runBlocking
import java.io.File
import kotlin.coroutines.experimental.SequenceBuilder
import kotlin.coroutines.experimental.buildSequence


typealias ID = String
typealias Path = List<ID>

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
object App {
    @JvmStatic
    fun main(args: Array<String>) = runBlocking<Unit> {
        val n = if (args.isNotEmpty()) args[0] else "35"
        val graph = readGraph("../data/graph$n.adj")
        println(countCycles(graph))
    }

    suspend fun countCycles(graph: Graph): Int {
        // return findCycles(graph).count()
        var n = 0
        findCyclesSeq(graph).forEach {
            n += it.await().count()
        }
        return n
    }
}

suspend fun findCyclesSeq(graph: Graph): Sequence<Deferred<Sequence<Path>>> =
    graph.vertices().map { async { findCyclesSeq(listOf(it), graph) } }.asSequence()


suspend fun findCyclesSeq(path: Path, graph: Graph): Sequence<Path> {
    if (path.isEmpty()) {
        return sequenceOf()
    }
    val jobs = mutableListOf<Sequence<Path>>()
    for (tid in graph.edges(path.last())) {
        if (tid == path.first()) {
            jobs.add( sequenceOf(path) )
        } else if (tid > path.first() && !path.contains(tid)) {
            jobs.add( findCyclesSeq(path + listOf(tid), graph) )
        }
    }
    return jobs.flatMap { it.asIterable() }.asSequence()
}

suspend fun findCycles(graph: Graph): Sequence<List<ID>> = buildSequence {
    for (vertex in graph.vertices()) {
        findCycles(listOf(vertex), graph)
    }
}

suspend fun SequenceBuilder<List<ID>>.findCycles(path: List<ID>, graph: Graph)  {
    if (path.isEmpty()) {
        return
    }
    for (tid in graph.edges(path.last())) {
        if (tid == path.first()) {
            yield(path)
        } else if (tid > path.first() && !path.contains(tid)) {
            findCycles(path + listOf(tid), graph)
        }
    }
}

fun readGraph(path: String): Graph =
        MapGraph(File(path).readLines(Charsets.UTF_8)
                .map { it.trim() }
                .filter { !it.startsWith("#") }
                .filter { !it.isEmpty() }
                .map { it.split(Regex("\\s"))}
                .map { it[0] to it.subList(1, it.size).asSequence()
                }.toMap())



interface Graph {
    fun vertices(): Sequence<ID>
    fun edges(vertex: ID): Sequence<ID>
}

class MapGraph(private val vs: Map<ID, Sequence<ID>>): Graph {
    override fun vertices(): Sequence<ID> = vs.keys.asSequence()

    override fun edges(vertex: ID): Sequence<ID> = vs[vertex] ?: sequenceOf()
}
